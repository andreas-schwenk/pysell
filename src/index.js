import {
  genButton,
  genDiv,
  genInputField,
  genLi,
  genMathSpan,
  genSpan,
  genUl,
} from "./dom.js";
import {
  iconSquareChecked,
  iconSquareUnchecked,
  iconPlay,
  iconCircleUnchecked,
  iconCircleChecked,
} from "./icons.js";
import { courseInfo1, courseInfo2, courseInfo3 } from "./lang.js";
import { Matrix, Term, shuffledIndices, unShuffledIndices } from "./math.js";

class Question {
  /**
   * @param {Object.<Object,Object>} src
   * @param {boolean} [debug=false]
   */
  constructor(src, debug = false) {
    this.src = src;
    this.debug = debug;
    this.instanceIdx = Math.floor(Math.random() * src.instances.length);
    this.choiceIdx = 0; // distinct index for every multi or single choice
    this.gapIdx = 0; // distinct index for every gap field
    this.expected = {};
    this.types = {}; // variable types of this.expected
    this.student = {};
    this.inputs = {}; // html input elements (currently ONLY used for type gap)
    this.qDiv = null;
    this.titleDiv = null;
    this.checkBtn = null;
    this.showSolution = false;
  }

  /**
   * @param {HTMLElement} parent
   */
  populateDom(parent) {
    // generate question div
    this.qDiv = genDiv();
    parent.appendChild(this.qDiv);
    this.qDiv.classList.add("question");
    // generate question title
    this.titleDiv = genDiv();
    this.qDiv.appendChild(this.titleDiv);
    this.titleDiv.classList.add("questionTitle");
    this.titleDiv.innerHTML = this.src["title"];
    // error?
    if (this.src["error"].length > 0) {
      let errorSpan = genSpan(this.src["error"]);
      this.qDiv.appendChild(errorSpan);
      errorSpan.style.color = "red";
      return;
    }
    // generate question text
    for (let c of this.src.text.children)
      this.qDiv.appendChild(this.generateText(c));
    // generate button row
    let buttonDiv = genDiv();
    this.qDiv.appendChild(buttonDiv);
    buttonDiv.classList.add("buttonRow");
    // (a) check button
    let hasCheckButton = Object.keys(this.expected).length > 0;
    if (hasCheckButton) {
      this.checkBtn = genButton();
      buttonDiv.appendChild(this.checkBtn);
      this.checkBtn.innerHTML = iconPlay;
    }
    // (b) spacing
    let space = genSpan("&nbsp;&nbsp;&nbsp;");
    buttonDiv.appendChild(space);
    // (c) feedback text
    let feedbackSpan = genSpan("");
    buttonDiv.appendChild(feedbackSpan);
    // debug text (variables, python src, text src)
    if (this.debug) {
      if (this.src.variables.length > 0) {
        // variables title
        let title = genDiv();
        title.classList.add("debugInfo");
        title.innerHTML = "Variables generated by Python Code";
        this.qDiv.appendChild(title);
        // variables
        let varDiv = genDiv();
        varDiv.classList.add("debugCode");
        this.qDiv.appendChild(varDiv);
        let instance = this.src.instances[this.instanceIdx];
        let html = "";
        let variables = [...this.src["variables"]];
        variables.sort();
        for (let v of variables) {
          let type = instance[v].type;
          let value = instance[v].value;
          switch (type) {
            case "vector":
              value = "[" + value + "]";
              break;
            case "set":
              value = "{" + value + "}";
              break;
          }
          html += type + " " + v + " = " + value + "; <br/>";
        }
        varDiv.innerHTML = html;
      }
      let sources = ["python_src_html", "text_src_html"];
      let titles = ["Python Source Code", "Text Source Code"];
      for (let i = 0; i < sources.length; i++) {
        let key = sources[i];
        if (key in this.src && this.src[key].length > 0) {
          // title
          let title = genDiv();
          title.classList.add("debugInfo");
          title.innerHTML = titles[i];
          this.qDiv.appendChild(title);
          // source code
          let code = genDiv();
          code.classList.add("debugCode");
          this.qDiv.append(code);
          code.innerHTML = this.src[key];
        }
      }
    }
    // evaluation
    if (hasCheckButton) {
      this.checkBtn.addEventListener("click", () => {
        feedbackSpan.innerHTML = "";
        let numChecked = 0;
        let numCorrect = 0;
        for (let id in this.expected) {
          //console.log("comparing answer " + id);
          let type = this.types[id];
          //console.log("type = " + type);
          let student = this.student[id];
          //console.log("student = " + student);
          let expected = this.expected[id];
          //console.log("expected = " + expected);
          switch (type) {
            case "bool":
              if (student === expected) numCorrect++;
              break;
            case "string": {
              let inputField = this.inputs[id];
              let s = student.trim().toUpperCase();
              let e = expected.trim().toUpperCase();
              let ok = s === e;
              if (ok) numCorrect++;
              inputField.style.color = ok ? "black" : "white";
              inputField.style.backgroundColor = ok ? "transparent" : "red";
              break;
            }
            case "int":
            case "float":
              if (Math.abs(parseFloat(student) - parseFloat(expected)) < 1e-9)
                numCorrect++;
              break;
            case "term": {
              try {
                let u = new Term();
                u.parse(expected);
                let v = new Term();
                v.parse(student);
                if (u.compare(v)) numCorrect++;
              } catch (e) {}
              break;
            }
            case "vector":
            case "complex":
            case "set": {
              expected = expected.split(",");
              numChecked += expected.length - 1;
              student = [];
              for (let i = 0; i < expected.length; i++)
                student.push(this.student[id + "-" + i]);
              if (type === "set") {
                for (let i = 0; i < expected.length; i++) {
                  let ei = parseFloat(expected[i]);
                  for (let j = 0; j < student.length; j++) {
                    let sj = parseFloat(student[j]);
                    if (Math.abs(sj - ei) < 1e-9) {
                      numCorrect++;
                      break;
                    }
                  }
                }
              } else {
                // vector or complex
                for (let i = 0; i < expected.length; i++) {
                  let si = parseFloat(student[i]);
                  let ei = parseFloat(expected[i]);
                  if (Math.abs(si - ei) < 1e-9) numCorrect++;
                }
              }
              break;
            }
            case "matrix": {
              let mat = new Matrix();
              mat.fromString(expected);
              numChecked += mat.m * mat.n - 1;
              for (let i = 0; i < mat.m; i++) {
                for (let j = 0; j < mat.n; j++) {
                  let idx = i * mat.m + j;
                  student = parseFloat(this.student[id + "-" + idx]);
                  if (Math.abs(mat.v[idx] - student) < 1e-9) numCorrect++;
                }
              }
              break;
            }
            default:
              feedbackSpan.innerHTML = "UNIMPLEMENTED EVAL OF TYPE " + type;
          }
          numChecked++;
        }
        if (numCorrect == numChecked) {
          feedbackSpan.style.color =
            this.titleDiv.style.color =
            this.checkBtn.style.backgroundColor =
            this.qDiv.style.borderColor =
              "rgb(0,150,0)";
          this.qDiv.style.backgroundColor = "rgba(0,150,0, 0.025)";
        } else {
          this.titleDiv.style.color =
            feedbackSpan.style.color =
            this.checkBtn.style.backgroundColor =
            this.qDiv.style.borderColor =
              "rgb(150,0,0)";
          this.qDiv.style.backgroundColor = "rgba(150,0,0, 0.025)";
          if (numChecked >= 5) {
            feedbackSpan.innerHTML = "" + numCorrect + " / " + numChecked;
          }
        }
      });
    }
  }

  /**
   * @param {Object.<Object,Object>} node
   * @returns {string}
   */
  generateMathString(node) {
    let s = "";
    switch (node.type) {
      case "math":
        for (let c of node.children) s += this.generateMathString(c);
        break;
      case "text":
        return node.data;
      case "var": {
        let instance = this.src.instances[this.instanceIdx];
        let type = instance[node.data].type;
        let value = instance[node.data].value;
        switch (type) {
          case "vector":
            return "\\left[" + value + "\\right]";
          case "set":
            return "\\left\\{" + value + "\\right\\}";
          case "complex": {
            let tk = value.split(",");
            let real = parseFloat(tk[0]);
            let imag = parseFloat(tk[1]);
            let s = "";
            if (Math.abs(real) > 1e-9) s += real;
            if (Math.abs(imag) > 1e-9) s += (imag < 0 ? "-" : "+") + imag + "i";
            return s;
          }
          case "matrix": {
            // e.g. "[[1,2,3],[4,5,6]]" -> "\begin{pmatrix}1&2&3\\4%5%6\end{pmatrix}"
            s =
              "\\begin{bmatrix}" +
              value
                .replaceAll("],[", "\\\\")
                .replaceAll(",", "&")
                .replaceAll("[", "")
                .replaceAll("]", "") +
              "\\end{bmatrix}";
            return s;
          }
          case "term": {
            // TODO: parse with parenthesis info
            //     + output with \frac, ...
            // TODO: sqrt, ...
            s = value
              .replaceAll("sin", "\\sin")
              .replaceAll("cos", "\\cos")
              .replaceAll("tan", "\\tan")
              .replaceAll("exp", "\\exp")
              .replaceAll("ln", "\\ln")
              .replaceAll("*", "\\cdot")
              .replaceAll("(", "\\left(")
              .replaceAll(")", "\\right)");
            break;
          }
          default:
            s = value;
        }
      }
    }
    return s;
  }

  /**
   * @param {boolean} left
   * @param {number} rowSpan
   * @returns {HTMLTableCellElement}
   */
  generateMatrixParenthesis(left, rowSpan) {
    let cell = document.createElement("td");
    cell.style.width = "3px";
    for (let side of ["Top", left ? "Left" : "Right", "Bottom"]) {
      cell.style["border" + side + "Width"] = "2px";
      cell.style["border" + side + "Style"] = "solid";
    }
    cell.rowSpan = rowSpan;
    return cell;
  }

  /**
   * @param {Object.<Object,Object>} node
   * @param {boolean} spanInsteadParagraph
   * @returns {HTMLElement}
   */
  generateText(node, spanInsteadParagraph = false) {
    switch (node.type) {
      case "paragraph":
      case "span": {
        let e = document.createElement(
          node.type == "span" || spanInsteadParagraph ? "span" : "p"
        );
        for (let c of node.children) e.appendChild(this.generateText(c));
        return e;
      }
      case "text": {
        return genSpan(node.data);
      }
      case "code": {
        let span = genSpan(node.data);
        span.classList.add("code");
        return span;
      }
      case "italic":
      case "bold": {
        let span = genSpan("");
        span.append(...node.children.map((c) => this.generateText(c)));
        if (node.type === "bold") span.style.fontWeight = "bold";
        else span.style.fontStyle = "italic";
        return span;
      }
      case "math": {
        return genMathSpan(this.generateMathString(node));
      }
      case "gap": {
        let span = genSpan("");
        let width = Math.max(node.data.length * 12, 24);
        let input = genInputField(width);
        let id = "gap-" + this.gapIdx;
        this.inputs[id] = input;
        this.expected[id] = node.data;
        this.types[id] = "string";
        input.addEventListener("keyup", () => {
          this.student[id] = input.value.trim();
        });
        if (this.showSolution)
          this.student[id] = input.value = this.expected[id];
        this.gapIdx++;
        span.appendChild(input);
        return span;
      }
      case "input":
      case "input2": {
        let suppressParentheses = node.type === "input2";
        let span = genSpan("");
        span.style.verticalAlign = "text-bottom";
        let id = node.data;
        let expected = this.src.instances[this.instanceIdx][id];
        this.expected[id] = expected.value;
        this.types[id] = expected.type;
        if (!suppressParentheses)
          switch (expected.type) {
            case "set":
              span.append(genMathSpan("\\{"), genSpan(" "));
              break;
            case "vector":
              span.append(genMathSpan("["), genSpan(" "));
              break;
          }
        if (expected.type === "vector" || expected.type === "set") {
          // vector or set
          let elements = expected.value.split(",");
          let n = elements.length;
          for (let i = 0; i < n; i++) {
            if (i > 0) span.appendChild(genSpan(" , "));
            let input = genInputField(Math.max(elements[i].length * 12, 24));
            span.appendChild(input);
            input.addEventListener("keyup", () => {
              this.student[id + "-" + i] = input.value.trim();
            });
            if (this.showSolution)
              this.student[id + "-" + i] = input.value = elements[i];
          }
        } else if (expected.type === "matrix") {
          // matrix
          let mat = new Matrix();
          mat.fromString(expected.value);
          let table = document.createElement("table");
          span.appendChild(table);
          let cellWidth = mat.getMaxCellStrlen();
          cellWidth = Math.max(cellWidth * 12, 24);
          for (let i = 0; i < mat.m; i++) {
            let row = document.createElement("tr");
            table.appendChild(row);
            if (i == 0)
              row.appendChild(this.generateMatrixParenthesis(true, mat.m));
            for (let j = 0; j < mat.n; j++) {
              let idx = i * mat.n + j;
              let cell = document.createElement("td");
              row.appendChild(cell);
              let input = genInputField(cellWidth);
              input.style.textAlign = "end";
              cell.appendChild(input);
              input.addEventListener("keyup", () => {
                this.student[id + "-" + idx] = input.value.trim();
              });
              if (this.showSolution)
                this.student[id + "-" + idx] = input.value = "" + mat.v[idx];
            }
            if (i == 0)
              row.appendChild(this.generateMatrixParenthesis(false, mat.m));
          }
        } else if (expected.type === "complex") {
          // complex number in normal form
          let elements = expected.value.split(",");
          for (let i = 0; i < 2; i++) {
            let input = genInputField(
              Math.max(Math.max(elements[i].length * 12, 24), 24)
            );
            span.appendChild(input);
            if (this.showSolution)
              this.student[id + "-" + i] = input.value = elements[i];
            input.addEventListener("keyup", () => {
              this.student[id + "-" + i] = input.value.trim();
            });
            if (i == 0)
              span.append(genSpan(" "), genMathSpan("+"), genSpan(" "));
            else span.append(genSpan(" "), genMathSpan("i"));
          }
        } else {
          // scalar
          let input = genInputField(Math.max(expected.value.length * 12, 24));
          span.appendChild(input);
          input.addEventListener("keyup", () => {
            this.student[id] = input.value.trim();
          });
          if (this.showSolution)
            this.student[id] = input.value = expected.value;
        }
        if (!suppressParentheses)
          switch (expected.type) {
            case "set":
              span.append(genSpan(" "), genMathSpan("\\}"));
              break;
            case "vector":
              span.append(genSpan(" "), genMathSpan("]"));
              break;
          }
        return span;
      }
      case "itemize": {
        return genUl(node.children.map((c) => genLi(this.generateText(c))));
      }
      case "single-choice":
      case "multi-choice": {
        let mc = node.type == "multi-choice";
        let table = document.createElement("table");
        let n = node.children.length;
        let order = this.debug ? unShuffledIndices(n) : shuffledIndices(n);
        let iconCorrect = mc ? iconSquareChecked : iconCircleChecked;
        let iconIncorrect = mc ? iconSquareUnchecked : iconCircleUnchecked;
        let checkboxes = [];
        let answerIDs = [];
        for (let i = 0; i < n; i++) {
          let idx = order[i];
          let answer = node.children[idx];
          let answerId = "mc-" + this.choiceIdx + "-" + idx;
          answerIDs.push(answerId);
          let expectedValue = answer.children[0].data;
          this.expected[answerId] = expectedValue;
          this.types[answerId] = "bool";
          this.student[answerId] = this.showSolution ? expectedValue : "false";
          let text = this.generateText(answer.children[1], true);
          // dom
          let tr = document.createElement("tr");
          table.appendChild(tr);
          tr.style.cursor = "pointer";
          let tdCheckBox = document.createElement("td");
          checkboxes.push(tdCheckBox);
          tr.appendChild(tdCheckBox);
          tdCheckBox.innerHTML =
            this.student[answerId] == "true" ? iconCorrect : iconIncorrect;
          let tdText = document.createElement("td");
          tr.appendChild(tdText);
          tdText.appendChild(text);
          if (mc) {
            // multi-choice
            tr.addEventListener("click", () => {
              this.student[answerId] =
                this.student[answerId] === "true" ? "false" : "true";
              if (this.student[answerId] === "true")
                tdCheckBox.innerHTML = iconCorrect;
              else tdCheckBox.innerHTML = iconIncorrect;
            });
          } else {
            // single-choice
            tr.addEventListener("click", () => {
              for (let id of answerIDs) this.student[id] = "false";
              this.student[answerId] = "true";
              for (let i = 0; i < answerIDs.length; i++) {
                let idx = order[i];
                checkboxes[idx].innerHTML =
                  this.student[answerIDs[idx]] == "true"
                    ? iconCorrect
                    : iconIncorrect;
              }
            });
          }
        }
        this.choiceIdx++;
        return table;
      }
      default: {
        let span = genSpan("UNIMPLEMENTED(" + node.type + ")");
        span.style.color = "red";
        return span;
      }
    }
  }
}

/**
 * @param {Object.<Object,Object>} quizSrc
 * @param {boolean} debug
 */
export function init(quizSrc, debug) {
  if (debug) document.getElementById("debug").style.display = "block";
  document.getElementById("title").innerHTML = quizSrc.title;
  document.getElementById("author").innerHTML = quizSrc.author;
  document.getElementById("courseInfo1").innerHTML = courseInfo1[quizSrc.lang];
  let reload =
    '<span onclick="location.reload()" style="text-decoration: underline; font-weight: bold; cursor: pointer">' +
    courseInfo3[quizSrc.lang] +
    "</span>";
  document.getElementById("courseInfo2").innerHTML = courseInfo2[
    quizSrc.lang
  ].replace("*", reload);

  /** @type {Question[]} */
  let questions = [];
  /** @type {HTMLElement} */
  let questionsDiv = document.getElementById("questions");
  let idx = 1;
  for (let questionSrc of quizSrc.questions) {
    questionSrc.title = "" + idx + ". " + questionSrc.title;
    let question = new Question(questionSrc, debug);
    question.showSolution = debug;
    questions.push(question);
    question.populateDom(questionsDiv);
    if (debug && questionSrc.error.length == 0) question.checkBtn.click();
    idx++;
  }
}
