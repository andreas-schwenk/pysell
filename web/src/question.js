/*******************************************************************************
 * pySELL - Python based Simple E-Learning Language
 * AUTHOR:  Andreas Schwenk <mailto:contact@compiler-construction.com>
 * LICENSE: GPLv3
 ******************************************************************************/

import {
  genButton,
  genDiv,
  genInputField,
  genLi,
  genMathSpan,
  genSpan,
  genUl,
} from "./dom.js";
import {
  iconSquareChecked,
  iconSquareUnchecked,
  iconPlay,
  iconCircleUnchecked,
  iconCircleChecked,
} from "./icons.js";
import { Matrix, Term, shuffledIndices, unShuffledIndices } from "./math.js";

export class Question {
  /**
   * @param {Object.<Object,Object>} src
   * @param {boolean} [debug=false]
   */
  constructor(src, debug = false) {
    this.src = src;
    this.debug = debug;
    this.instanceIdx = Math.floor(Math.random() * src.instances.length);
    this.choiceIdx = 0; // distinct index for every multi or single choice
    this.gapIdx = 0; // distinct index for every gap field
    this.expected = {};
    this.types = {}; // variable types of this.expected
    this.student = {};
    this.inputs = {}; // html input elements (currently ONLY used for type gap)
    this.qDiv = null;
    this.titleDiv = null;
    this.checkBtn = null;
    this.showSolution = false;
  }

  /**
   * @param {HTMLElement} parent
   */
  populateDom(parent) {
    // generate question div
    this.qDiv = genDiv();
    parent.appendChild(this.qDiv);
    this.qDiv.classList.add("question");
    // generate question title
    this.titleDiv = genDiv();
    this.qDiv.appendChild(this.titleDiv);
    this.titleDiv.classList.add("questionTitle");
    this.titleDiv.innerHTML = this.src["title"];
    // error?
    if (this.src["error"].length > 0) {
      let errorSpan = genSpan(this.src["error"]);
      this.qDiv.appendChild(errorSpan);
      errorSpan.style.color = "red";
      return;
    }
    // generate question text
    for (let c of this.src.text.children)
      this.qDiv.appendChild(this.generateText(c));
    // generate button row
    let buttonDiv = genDiv();
    this.qDiv.appendChild(buttonDiv);
    buttonDiv.classList.add("buttonRow");
    // (a) check button
    let hasCheckButton = Object.keys(this.expected).length > 0;
    if (hasCheckButton) {
      this.checkBtn = genButton();
      buttonDiv.appendChild(this.checkBtn);
      this.checkBtn.innerHTML = iconPlay;
    }
    // (b) spacing
    let space = genSpan("&nbsp;&nbsp;&nbsp;");
    buttonDiv.appendChild(space);
    // (c) feedback text
    let feedbackSpan = genSpan("");
    buttonDiv.appendChild(feedbackSpan);
    // debug text (variables, python src, text src)
    if (this.debug) {
      if (this.src.variables.length > 0) {
        // variables title
        let title = genDiv();
        title.classList.add("debugInfo");
        title.innerHTML = "Variables generated by Python Code";
        this.qDiv.appendChild(title);
        // variables
        let varDiv = genDiv();
        varDiv.classList.add("debugCode");
        this.qDiv.appendChild(varDiv);
        let instance = this.src.instances[this.instanceIdx];
        let html = "";
        let variables = [...this.src["variables"]];
        variables.sort();
        for (let v of variables) {
          let type = instance[v].type;
          let value = instance[v].value;
          switch (type) {
            case "vector":
              value = "[" + value + "]";
              break;
            case "set":
              value = "{" + value + "}";
              break;
          }
          html += type + " " + v + " = " + value + "<br/>";
        }
        varDiv.innerHTML = html;
      }
      let sources = ["python_src_html", "text_src_html"];
      let titles = ["Python Source Code", "Text Source Code"];
      for (let i = 0; i < sources.length; i++) {
        let key = sources[i];
        if (key in this.src && this.src[key].length > 0) {
          // title
          let title = genDiv();
          title.classList.add("debugInfo");
          title.innerHTML = titles[i];
          this.qDiv.appendChild(title);
          // source code
          let code = genDiv();
          code.classList.add("debugCode");
          this.qDiv.append(code);
          code.innerHTML = this.src[key];
        }
      }
    }
    // evaluation
    if (hasCheckButton) {
      this.checkBtn.addEventListener("click", () => {
        feedbackSpan.innerHTML = "";
        let numChecked = 0;
        let numCorrect = 0;
        for (let id in this.expected) {
          //console.log("comparing answer " + id);
          let type = this.types[id];
          //console.log("type = " + type);
          let student = this.student[id];
          //console.log("student = " + student);
          let expected = this.expected[id];
          //console.log("expected = " + expected);
          switch (type) {
            case "bool":
              if (student === expected) numCorrect++;
              break;
            case "string": {
              let inputField = this.inputs[id];
              let s = student.trim().toUpperCase();
              let e = expected.trim().toUpperCase();
              let ok = s === e;
              if (ok) numCorrect++;
              inputField.style.color = ok ? "black" : "white";
              inputField.style.backgroundColor = ok ? "transparent" : "red";
              break;
            }
            case "int":
            case "float":
              if (Math.abs(parseFloat(student) - parseFloat(expected)) < 1e-9)
                numCorrect++;
              break;
            case "term": {
              try {
                let u = new Term();
                u.parse(expected);
                let v = new Term();
                v.parse(student);
                if (u.compare(v)) numCorrect++;
              } catch (e) {
                if (this.debug) {
                  console.log(e);
                }
              }
              break;
            }
            case "vector":
            case "complex":
            case "set": {
              expected = expected.split(",");
              numChecked += expected.length - 1;
              student = [];
              for (let i = 0; i < expected.length; i++)
                student.push(this.student[id + "-" + i]);
              if (type === "set") {
                for (let i = 0; i < expected.length; i++) {
                  let ei = parseFloat(expected[i]);
                  for (let j = 0; j < student.length; j++) {
                    let sj = parseFloat(student[j]);
                    if (Math.abs(sj - ei) < 1e-9) {
                      numCorrect++;
                      break;
                    }
                  }
                }
              } else {
                // vector or complex
                for (let i = 0; i < expected.length; i++) {
                  let si = parseFloat(student[i]);
                  let ei = parseFloat(expected[i]);
                  if (Math.abs(si - ei) < 1e-9) numCorrect++;
                }
              }
              break;
            }
            case "matrix": {
              let mat = new Matrix(0, 0);
              mat.fromString(expected);
              numChecked += mat.m * mat.n - 1;
              for (let i = 0; i < mat.m; i++) {
                for (let j = 0; j < mat.n; j++) {
                  let idx = i * mat.n + j;
                  student = this.student[id + "-" + idx];
                  let e = mat.v[idx];
                  //console.log("comparing element " + student + " to " + e);
                  try {
                    let u = new Term();
                    u.parse(e);
                    let v = new Term();
                    v.parse(student);
                    if (u.compare(v)) numCorrect++;
                  } catch (e) {
                    if (this.debug) {
                      console.log(e);
                    }
                  }
                }
              }
              break;
            }
            default:
              feedbackSpan.innerHTML = "UNIMPLEMENTED EVAL OF TYPE " + type;
          }
          numChecked++;
        }
        if (numCorrect == numChecked) {
          feedbackSpan.style.color =
            this.titleDiv.style.color =
            this.checkBtn.style.backgroundColor =
            this.qDiv.style.borderColor =
              "rgb(0,150,0)";
          this.qDiv.style.backgroundColor = "rgba(0,150,0, 0.025)";
        } else {
          this.titleDiv.style.color =
            feedbackSpan.style.color =
            this.checkBtn.style.backgroundColor =
            this.qDiv.style.borderColor =
              "rgb(150,0,0)";
          this.qDiv.style.backgroundColor = "rgba(150,0,0, 0.025)";
          if (numChecked >= 5) {
            feedbackSpan.innerHTML = "" + numCorrect + " / " + numChecked;
          }
        }
      });
    }
  }

  /**
   * @param {Object.<Object,Object>} node
   * @returns {string}
   */
  generateMathString(node) {
    let s = "";
    switch (node.type) {
      case "math":
      case "display-math":
        for (let c of node.children) s += this.generateMathString(c);
        break;
      case "text":
        return node.data;
      case "var": {
        let instance = this.src.instances[this.instanceIdx];
        let type = instance[node.data].type;
        let value = instance[node.data].value;
        switch (type) {
          case "vector":
            return "\\left[" + value + "\\right]";
          case "set":
            return "\\left\\{" + value + "\\right\\}";
          case "complex": {
            let tk = value.split(",");
            let real = parseFloat(tk[0]);
            let imag = parseFloat(tk[1]);
            let s = "";
            if (Math.abs(real) > 1e-9) s += real;
            if (Math.abs(imag) > 1e-9) s += (imag < 0 ? "-" : "+") + imag + "i";
            return s;
          }
          case "matrix": {
            // e.g. "[[1,2,3],[4,5,6]]" -> "\begin{pmatrix}1&2&3\\4%5%6\end{pmatrix}"
            let mat = new Matrix(0, 0);
            mat.fromString(value);
            s = mat.toTeX(node.data.includes("augmented"));
            return s;
          }
          case "term": {
            // TODO: parse with parenthesis info
            //     + output with \frac, ...
            // TODO: sqrt, ...
            s = value
              .replaceAll("sin", "\\sin")
              .replaceAll("cos", "\\cos")
              .replaceAll("tan", "\\tan")
              .replaceAll("exp", "\\exp")
              .replaceAll("ln", "\\ln")
              .replaceAll("*", "\\cdot ")
              .replaceAll("(", "\\left(")
              .replaceAll(")", "\\right)");
            break;
          }
          default:
            s = value;
        }
      }
    }
    return s;
  }

  /**
   * @param {boolean} left
   * @param {number} rowSpan
   * @returns {HTMLTableCellElement}
   */
  generateMatrixParenthesis(left, rowSpan) {
    let cell = document.createElement("td");
    cell.style.width = "3px";
    for (let side of ["Top", left ? "Left" : "Right", "Bottom"]) {
      cell.style["border" + side + "Width"] = "2px";
      cell.style["border" + side + "Style"] = "solid";
    }
    cell.rowSpan = rowSpan;
    return cell;
  }

  /**
   * @param {HTMLInputElement} input
   */
  validateTermInput(input) {
    let t = new Term();
    let ok = true;
    let value = input.value;
    if (value.length > 0) {
      try {
        t.parse(value);
      } catch (e) {
        ok = false;
      }
    }
    input.style.color = ok ? "black" : "maroon";
    //input.style.fontStyle = ok ? "normal" : "italic";
  }

  /**
   * @param {Object.<Object,Object>} node
   * @param {boolean} spanInsteadParagraph
   * @returns {HTMLElement}
   */
  generateText(node, spanInsteadParagraph = false) {
    switch (node.type) {
      case "paragraph":
      case "span": {
        let e = document.createElement(
          node.type == "span" || spanInsteadParagraph ? "span" : "p"
        );
        for (let c of node.children) e.appendChild(this.generateText(c));
        return e;
      }
      case "text": {
        return genSpan(node.data);
      }
      case "code": {
        let span = genSpan(node.data);
        span.classList.add("code");
        return span;
      }
      case "italic":
      case "bold": {
        let span = genSpan("");
        span.append(...node.children.map((c) => this.generateText(c)));
        if (node.type === "bold") span.style.fontWeight = "bold";
        else span.style.fontStyle = "italic";
        return span;
      }
      case "math":
      case "display-math": {
        let tex = this.generateMathString(node);
        return genMathSpan(tex, node.type === "display-math");
      }
      case "gap": {
        let span = genSpan("");
        let width = Math.max(node.data.length * 12, 24);
        let input = genInputField(width);
        let id = "gap-" + this.gapIdx;
        this.inputs[id] = input;
        this.expected[id] = node.data;
        this.types[id] = "string";
        input.addEventListener("keyup", () => {
          this.student[id] = input.value.trim();
        });
        if (this.showSolution)
          this.student[id] = input.value = this.expected[id];
        this.gapIdx++;
        span.appendChild(input);
        return span;
      }
      case "input":
      case "input2": {
        let suppressParentheses = node.type === "input2";
        let span = genSpan("");
        span.style.verticalAlign = "text-bottom";
        let id = node.data;
        let expected = this.src.instances[this.instanceIdx][id];
        this.expected[id] = expected.value;
        this.types[id] = expected.type;
        if (!suppressParentheses)
          switch (expected.type) {
            case "set":
              span.append(genMathSpan("\\{"), genSpan(" "));
              break;
            case "vector":
              span.append(genMathSpan("["), genSpan(" "));
              break;
          }
        if (expected.type === "vector" || expected.type === "set") {
          // TODO: resizable
          // vector or set
          let elements = expected.value.split(",");
          let n = elements.length;
          for (let i = 0; i < n; i++) {
            if (i > 0) span.appendChild(genSpan(" , "));
            let input = genInputField(Math.max(elements[i].length * 12, 24));
            span.appendChild(input);
            input.addEventListener("keyup", () => {
              this.student[id + "-" + i] = input.value.trim();
              this.validateTermInput(input);
            });
            if (this.showSolution)
              this.student[id + "-" + i] = input.value = elements[i];
          }
        } else if (expected.type === "matrix") {
          /**
           * @param {HTMLDivElement} parent
           * @param {Matrix} matExpected
           * @param {Matrix} matStudent
           */
          let genMatrixDom = (parent, matExpected, matStudent) => {
            // parent div
            let div = genDiv();
            parent.innerHTML = "";
            parent.appendChild(div);
            div.style.position = "relative";
            div.style.display = "inline-block";
            // core matrix
            let table = document.createElement("table");
            div.appendChild(table);
            let cellWidth = matExpected.getMaxCellStrlen();
            cellWidth = Math.max(cellWidth * 12, 24);
            for (let i = 0; i < matStudent.m; i++) {
              let row = document.createElement("tr");
              table.appendChild(row);
              if (i == 0)
                row.appendChild(
                  this.generateMatrixParenthesis(true, matStudent.m)
                );
              for (let j = 0; j < matStudent.n; j++) {
                let idx = i * matStudent.n + j;
                let cell = document.createElement("td");
                row.appendChild(cell);
                let input = genInputField(cellWidth);
                input.style.textAlign = "end";
                cell.appendChild(input);
                input.addEventListener("keyup", () => {
                  this.student[id + "-" + idx] = input.value.trim();
                  this.validateTermInput(input);
                });
                if (this.showSolution)
                  this.student[id + "-" + idx] = input.value =
                    "" + matStudent.v[idx];
              }
              if (i == 0)
                row.appendChild(
                  this.generateMatrixParenthesis(false, matStudent.m)
                );
            }
            // resize buttons [add col, remove col, add row, remove row]
            let text = ["+", "-", "+", "-"];
            let deltaM = [0, 0, 1, -1];
            let deltaN = [1, -1, 0, 0];
            let top = [0, 22, 888, 888];
            let bottom = [888, 888, -22, -22];
            let right = [-22, -22, 0, 22];
            let available = [
              matExpected.n != 1,
              matExpected.n != 1,
              matExpected.m != 1,
              matExpected.m != 1,
            ];
            let hidden = [
              matStudent.n >= 10,
              matStudent.n <= 1,
              matStudent.m >= 10,
              matStudent.m <= 1,
            ];
            for (let i = 0; i < 4; i++) {
              if (available[i] == false) continue;
              let btn = genSpan(text[i]);
              if (top[i] != 888) btn.style.top = "" + top[i] + "px";
              if (bottom[i] != 888) btn.style.bottom = "" + bottom[i] + "px";
              if (right[i] != 888) btn.style.right = "" + right[i] + "px";
              btn.classList.add("matrixResizeButton");
              div.appendChild(btn);
              if (hidden[i]) {
                btn.style.opacity = "0.5";
              } else {
                btn.addEventListener("click", () => {
                  matStudent.resize(
                    matStudent.m + deltaM[i],
                    matStudent.n + deltaN[i],
                    "0"
                  );
                  genMatrixDom(parent, matExpected, matStudent);
                });
              }
            }
          };
          let matExpected = new Matrix(0, 0);
          matExpected.fromString(expected.value);
          let matStudent = new Matrix(
            matExpected.m == 1 ? 1 : 3,
            matExpected.n == 1 ? 1 : 3
          );
          if (this.showSolution) matStudent.fromMatrix(matExpected);
          let parentDiv = genDiv();
          span.appendChild(parentDiv);
          genMatrixDom(parentDiv, matExpected, matStudent);
        } else if (expected.type === "complex") {
          // complex number in normal form
          let elements = expected.value.split(",");
          for (let i = 0; i < 2; i++) {
            let input = genInputField(
              Math.max(Math.max(elements[i].length * 12, 24), 24)
            );
            span.appendChild(input);
            if (this.showSolution)
              this.student[id + "-" + i] = input.value = elements[i];
            input.addEventListener("keyup", () => {
              this.student[id + "-" + i] = input.value.trim();
              this.validateTermInput(input);
            });
            if (i == 0)
              span.append(genSpan(" "), genMathSpan("+"), genSpan(" "));
            else span.append(genSpan(" "), genMathSpan("i"));
          }
        } else {
          // scalar
          let input = genInputField(Math.max(expected.value.length * 12, 24));
          span.appendChild(input);
          input.addEventListener("keyup", () => {
            this.student[id] = input.value.trim();
            this.validateTermInput(input);
          });
          if (this.showSolution)
            this.student[id] = input.value = expected.value;
        }
        if (!suppressParentheses)
          switch (expected.type) {
            case "set":
              span.append(genSpan(" "), genMathSpan("\\}"));
              break;
            case "vector":
              span.append(genSpan(" "), genMathSpan("]"));
              break;
          }
        return span;
      }
      case "itemize": {
        return genUl(node.children.map((c) => genLi(this.generateText(c))));
      }
      case "single-choice":
      case "multi-choice": {
        let mc = node.type == "multi-choice";
        let table = document.createElement("table");
        let n = node.children.length;
        let order = this.debug ? unShuffledIndices(n) : shuffledIndices(n);
        let iconCorrect = mc ? iconSquareChecked : iconCircleChecked;
        let iconIncorrect = mc ? iconSquareUnchecked : iconCircleUnchecked;
        let checkboxes = [];
        let answerIDs = [];
        for (let i = 0; i < n; i++) {
          let idx = order[i];
          let answer = node.children[idx];
          let answerId = "mc-" + this.choiceIdx + "-" + idx;
          answerIDs.push(answerId);
          let expectedValue =
            answer.children[0].type == "bool"
              ? answer.children[0].data
              : this.src.instances[this.instanceIdx][answer.children[0].data]
                  .value;
          this.expected[answerId] = expectedValue;
          this.types[answerId] = "bool";
          this.student[answerId] = this.showSolution ? expectedValue : "false";
          let text = this.generateText(answer.children[1], true);
          // dom
          let tr = document.createElement("tr");
          table.appendChild(tr);
          tr.style.cursor = "pointer";
          let tdCheckBox = document.createElement("td");
          checkboxes.push(tdCheckBox);
          tr.appendChild(tdCheckBox);
          tdCheckBox.innerHTML =
            this.student[answerId] == "true" ? iconCorrect : iconIncorrect;
          let tdText = document.createElement("td");
          tr.appendChild(tdText);
          tdText.appendChild(text);
          if (mc) {
            // multi-choice
            tr.addEventListener("click", () => {
              this.student[answerId] =
                this.student[answerId] === "true" ? "false" : "true";
              if (this.student[answerId] === "true")
                tdCheckBox.innerHTML = iconCorrect;
              else tdCheckBox.innerHTML = iconIncorrect;
            });
          } else {
            // single-choice
            tr.addEventListener("click", () => {
              for (let id of answerIDs) this.student[id] = "false";
              this.student[answerId] = "true";
              for (let i = 0; i < answerIDs.length; i++) {
                let idx = order[i];
                checkboxes[idx].innerHTML =
                  this.student[answerIDs[idx]] == "true"
                    ? iconCorrect
                    : iconIncorrect;
              }
            });
          }
        }
        this.choiceIdx++;
        return table;
      }
      default: {
        let span = genSpan("UNIMPLEMENTED(" + node.type + ")");
        span.style.color = "red";
        return span;
      }
    }
  }
}
